(*Generated by Lem from basic_classes.lem.*)
(******************************************************************************)
(* Basic Type Classes                                                         *)
(******************************************************************************)

open Lem_bool

(* ========================================================================== *)
(* Equality                                                                   *)
(* ========================================================================== *)

(* Lem`s default equality (=) is defined by the following type-class Eq.
   This typeclass should define equality on an abstract datatype 'a. It should
   always coincide with the default equality of Coq, HOL and Isabelle.
   For OCaml, it might be different, since abstract datatypes like sets
   might have fancy equalities. *)

type 'a eq_class= { 
  isEqual_method : 'a -> 'a -> bool;
  isInequal_method : 'a -> 'a -> bool
}


(* (=) should for all instances be an equivalence relation 
   The isEquivalence predicate of relations could be used here.
   However, this would lead to a cyclic dependency. *)

(* TODO: add later, once lemmata can be assigned to classes 
lemma eq_equiv: ((forall x. (x = x)) &&
                 (forall x y. (x = y) <-> (y = x)) &&
                 (forall x y z. ((x = y) && (y = z)) --> (x = z)))
*)

(* Structural equality *)

(* Sometimes, it is also handy to be able to use structural equality.
   This equality is mapped to the build-in equality of backends. This equality
   differs significantly for each backend. For example, OCaml can`t check equality
   of function types, whereas HOL can.  When using structural equality, one should 
   know what one is doing. The only guarentee is that is behaves like 
   the native backend equality.

   A lengthy name for structural equality is used to discourage its direct use.
   It also ensures that users realise it is unsafe (e.g. OCaml can`t check two functions
   for equality *)
(*val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool*)

(*val unsafe_structural_inequality : forall 'a. 'a -> 'a -> bool*)
let unsafe_structural_inequality x y:bool=  (not (x = y))

(* The default for equality is the unsafe structural one. It can 
   (and should) be overriden for concrete types later. *)

let instance_Basic_classes_Eq_var_dict:'a eq_class= ({

  isEqual_method = (=);

  isInequal_method = unsafe_structural_inequality})


(* ========================================================================== *)
(* Orderings                                                                  *)
(* ========================================================================== *)

(* The type-class Ord represents total orders (also called linear orders) *)
(*type ordering = LT | EQ | GT*)

(*let orderingIsLess r:bool=        (match r with LT -> true | _ -> false end)*)
(*let orderingIsGreater r:bool=     (match r with GT -> true | _ -> false end)*)
(*let orderingIsEqual r:bool=       (match r with EQ -> true | _ -> false end)*)

(*let ordering_cases r lt eq gt:'a= 
  if orderingIsLess r then lt else
  if orderingIsEqual r then eq else gt*)


(*val orderingEqual : ordering -> ordering -> bool*)

let instance_Basic_classes_Eq_Basic_classes_ordering_dict:(int)eq_class= ({

  isEqual_method = Lem.orderingEqual;

  isInequal_method = (fun x y->not (Lem.orderingEqual x y))})

type 'a ord_class= { 
  compare_method                 : 'a -> 'a -> int;
  isLess_method         : 'a -> 'a -> bool;
  isLessEqual_method    : 'a -> 'a -> bool;
  isGreater_method      : 'a -> 'a -> bool;
  isGreaterEqual_method : 'a -> 'a -> bool 
}


(* Ocaml provides default, polymorphic compare functions. Let's use them
   as the default. However, because used perhaps in a typeclass they must be 
   defined for all targets. So, explicitly declare them as undefined for
   all other targets. If explictly declare undefined, the type-checker won't complain and
   an error will only be raised when trying to actually output the function for a certain
   target. *)
(*val defaultCompare   : forall 'a. 'a -> 'a -> ordering*)
(*val defaultLess      : forall 'a. 'a -> 'a -> bool*)
(*val defaultLessEq    : forall 'a. 'a -> 'a -> bool*)
(*val defaultGreater   : forall 'a. 'a -> 'a -> bool*)
(*val defaultGreaterEq : forall 'a. 'a -> 'a -> bool*) 


let genericCompare (less: 'a -> 'a -> bool) (equal: 'a -> 'a -> bool) (x : 'a) (y : 'a):int=  
 (if less x y then
    (-1)
  else if equal x y then
    0
  else
    1)


(*
(* compare should really be a total order *)
lemma ord_OK_1: (
  (forall x y. (compare x y = EQ) <-> (compare y x = EQ)) &&
  (forall x y. (compare x y = LT) <-> (compare y x = GT)))

lemma ord_OK_2: (
  (forall x y z. (x <= y) && (y <= z) --> (x <= z)) &&
  (forall x y. (x <= y) || (y <= x))
)
*)

(* let's derive a compare function from the Ord type-class *)
(*val ordCompare : forall 'a. Eq 'a, Ord 'a => 'a -> 'a -> ordering*)
let ordCompare dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a x y:int=  
 (if ( dict_Basic_classes_Ord_a.isLess_method x y) then (-1) else
  if ( dict_Basic_classes_Eq_a.isEqual_method x y) then 0 else 1)

type 'a ordMaxMin_class= { 
  max_method : 'a -> 'a -> 'a;
  min_method : 'a -> 'a -> 'a
}

(*val minByLessEqual : forall 'a. ('a -> 'a -> bool) -> 'a -> 'a -> 'a*)
let minByLessEqual le x y:'a=  (if (le x y) then x else y)

(*val maxByLessEqual : forall 'a. ('a -> 'a -> bool) -> 'a -> 'a -> 'a*)
let maxByLessEqual le x y:'a=  (if (le y x) then x else y)

(*val defaultMax : forall 'a. Ord 'a => 'a -> 'a -> 'a*)

(*val defaultMin : forall 'a. Ord 'a => 'a -> 'a -> 'a*)

let instance_Basic_classes_OrdMaxMin_var_dict dict_Basic_classes_Ord_a:'a ordMaxMin_class= ({

  max_method = max;

  min_method = min})


(* ========================================================================== *)
(* SetTypes                                                                   *)
(* ========================================================================== *)

(* Set implementations use often an order on the elements. This allows the OCaml implementation
   to use trees for implementing them. At least, one needs to be able to check equality on sets.
   One could use the Ord type-class for sets. However, defining a special typeclass is cleaner
   and allows more flexibility. One can make e.g. sure, that this type-class is ignored for
   backends like HOL or Isabelle, which don't need it. Moreover, one is not forced to also instantiate
   the functions "<", "<=" ... *)

type 'a setType_class= { 
  setElemCompare_method : 'a -> 'a -> int
}

let instance_Basic_classes_SetType_var_dict:'a setType_class= ({

  setElemCompare_method = compare})

(* ========================================================================== *)
(* Instantiations                                                             *)
(* ========================================================================== *)

let instance_Basic_classes_Eq_bool_dict:(bool)eq_class= ({

  isEqual_method = (=);

  isInequal_method = (fun x y->not ((=) x y))})

let boolCompare b1 b2:int=  ((match (b1, b2) with
  | (true, true) -> 0
  | (true, false) -> 1
  | (false, true) -> (-1)
  | (false, false) -> 0
))

let instance_Basic_classes_SetType_bool_dict:(bool)setType_class= ({

  setElemCompare_method = boolCompare})

(* strings *)

(*val charEqual : char -> char -> bool*)

let instance_Basic_classes_Eq_char_dict:(char)eq_class= ({

  isEqual_method = (=);

  isInequal_method = (fun left right->not (left = right))})

(*val stringEquality : string -> string -> bool*)

let instance_Basic_classes_Eq_string_dict:(string)eq_class= ({

  isEqual_method = (=);

  isInequal_method = (fun l r->not (l = r))})

(* pairs *)

(*val pairEqual : forall 'a 'b. Eq 'a, Eq 'b => ('a * 'b) -> ('a * 'b) -> bool*)
(*let pairEqual (a1, b1) (a2, b2):bool=  ( 
  dict_Basic_classes_Eq_a.isEqual_method a1 a2) && ( dict_Basic_classes_Eq_b.isEqual_method b1 b2)*)

(*val pairEqualBy : forall 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a * 'b) -> ('a * 'b) -> bool*)

let instance_Basic_classes_Eq_tup2_dict dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b:('a*'b)eq_class= ({

  isEqual_method = (Lem.pair_equal  
  dict_Basic_classes_Eq_a.isEqual_method  dict_Basic_classes_Eq_b.isEqual_method);

  isInequal_method = (fun x y->not ((Lem.pair_equal  
  dict_Basic_classes_Eq_a.isEqual_method  dict_Basic_classes_Eq_b.isEqual_method x y)))})

(*val pairCompare : forall 'a 'b. ('a -> 'a -> ordering) -> ('b -> 'b -> ordering) -> ('a * 'b) -> ('a * 'b) -> ordering*)
let pairCompare cmpa cmpb (a1, b1) (a2, b2):int= 
  (Lem.ordering_cases (cmpa a1 a2) (-1) (cmpb b1 b2) 1)

let pairLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b (x1, x2) (y1, y2):bool=  (( 
  dict_Basic_classes_Ord_b.isLess_method x1 y1) || (( dict_Basic_classes_Ord_b.isLessEqual_method x1 y1) && ( dict_Basic_classes_Ord_a.isLess_method x2 y2)))
let pairLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b (x1, x2) (y1, y2):bool=  (( 
  dict_Basic_classes_Ord_b.isLess_method x1 y1) || (( dict_Basic_classes_Ord_b.isLessEqual_method x1 y1) && ( dict_Basic_classes_Ord_a.isLessEqual_method x2 y2)))

let pairGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b x12 y12:bool=  (pairLess 
  dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y12 x12)
let pairGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b x12 y12:bool=  (pairLessEq 
  dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y12 x12)

let instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b:('a*'b)ord_class= ({

  compare_method = (pairCompare  
  dict_Basic_classes_Ord_a.compare_method  dict_Basic_classes_Ord_b.compare_method);

  isLess_method = 
  (pairLess dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isLessEqual_method = 
  (pairLessEq dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isGreater_method = 
  (pairGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b);

  isGreaterEqual_method = 
  (pairGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b)})

let instance_Basic_classes_SetType_tup2_dict dict_Basic_classes_SetType_a dict_Basic_classes_SetType_b:('a*'b)setType_class= ({

  setElemCompare_method = (pairCompare  
  dict_Basic_classes_SetType_a.setElemCompare_method  dict_Basic_classes_SetType_b.setElemCompare_method)})


(* triples *)

(*val tripleEqual : forall 'a 'b 'c. Eq 'a, Eq 'b, Eq 'c => ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool*)
let tripleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c (x1, x2, x3) (y1, y2, y3):bool=  ( (Lem.pair_equal  
  dict_Basic_classes_Eq_a.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_b.isEqual_method  dict_Basic_classes_Eq_c.isEqual_method)(x1, (x2, x3)) (y1, (y2, y3))))

let instance_Basic_classes_Eq_tup3_dict dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c:('a*'b*'c)eq_class= ({

  isEqual_method = 
  (tripleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b
     dict_Basic_classes_Eq_c);

  isInequal_method = (fun x y->not (tripleEqual 
  dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c x y))})

(*val tripleCompare : forall 'a 'b 'c. ('a -> 'a -> ordering) -> ('b -> 'b -> ordering) -> ('c -> 'c -> ordering) -> ('a * 'b * 'c) -> ('a * 'b * 'c) -> ordering*)
let tripleCompare cmpa cmpb cmpc (a1, b1, c1) (a2, b2, c2):int=  
 (pairCompare cmpa (pairCompare cmpb cmpc) (a1, (b1, c1)) (a2, (b2, c2)))

let tripleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c (x1, x2, x3) (y1, y2, y3):bool=  (pairLess 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c) dict_Basic_classes_Ord_a (x1, (x2, x3)) (y1, (y2, y3)))
let tripleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c (x1, x2, x3) (y1, y2, y3):bool=  (pairLessEq 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c) dict_Basic_classes_Ord_a (x1, (x2, x3)) (y1, (y2, y3)))

let tripleGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c x123 y123:bool=  (tripleLess 
  dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y123 x123)
let tripleGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c x123 y123:bool=  (tripleLessEq 
  dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y123 x123)

let instance_Basic_classes_Ord_tup3_dict dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c:('a*'b*'c)ord_class= ({

  compare_method = (tripleCompare  
  dict_Basic_classes_Ord_a.compare_method  dict_Basic_classes_Ord_b.compare_method  dict_Basic_classes_Ord_c.compare_method);

  isLess_method = 
  (tripleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c);

  isLessEqual_method = 
  (tripleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c);

  isGreater_method = 
  (tripleGreater dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_a);

  isGreaterEqual_method = 
  (tripleGreaterEq dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_a)})

let instance_Basic_classes_SetType_tup3_dict dict_Basic_classes_SetType_a dict_Basic_classes_SetType_b dict_Basic_classes_SetType_c:('a*'b*'c)setType_class= ({

  setElemCompare_method = (tripleCompare  
  dict_Basic_classes_SetType_a.setElemCompare_method  dict_Basic_classes_SetType_b.setElemCompare_method  dict_Basic_classes_SetType_c.setElemCompare_method)})

(* quadruples *)

(*val quadrupleEqual : forall 'a 'b 'c 'd. Eq 'a, Eq 'b, Eq 'c, Eq 'd => ('a * 'b * 'c * 'd) -> ('a * 'b * 'c * 'd) -> bool*)
let quadrupleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d (x1, x2, x3, x4) (y1, y2, y3, y4):bool=  ( (Lem.pair_equal  
  dict_Basic_classes_Eq_a.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_b.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_c.isEqual_method  dict_Basic_classes_Eq_d.isEqual_method))(x1, (x2, (x3, x4))) (y1, (y2, (y3, y4)))))

let instance_Basic_classes_Eq_tup4_dict dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d:('a*'b*'c*'d)eq_class= ({

  isEqual_method = 
  (quadrupleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b
     dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d);

  isInequal_method = (fun x y->not (quadrupleEqual 
  dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d x y))})

(*val quadrupleCompare : forall 'a 'b 'c 'd. ('a -> 'a -> ordering) -> ('b -> 'b -> ordering) -> ('c -> 'c -> ordering) ->
                                              ('d -> 'd -> ordering) -> ('a * 'b * 'c * 'd) -> ('a * 'b * 'c * 'd) -> ordering*)
let quadrupleCompare cmpa cmpb cmpc cmpd (a1, b1, c1, d1) (a2, b2, c2, d2):int=  
 (pairCompare cmpa (pairCompare cmpb (pairCompare cmpc cmpd)) (a1, (b1, (c1, d1))) (a2, (b2, (c2, d2))))

let quadrupleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d (x1, x2, x3, x4) (y1, y2, y3, y4):bool=  (pairLess 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_c
        dict_Basic_classes_Ord_d)) dict_Basic_classes_Ord_a (x1, (x2, (x3, x4))) (y1, (y2, (y3, y4))))
let quadrupleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d (x1, x2, x3, x4) (y1, y2, y3, y4):bool=  (pairLessEq 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_c
        dict_Basic_classes_Ord_d)) dict_Basic_classes_Ord_a (x1, (x2, (x3, x4))) (y1, (y2, (y3, y4))))

let quadrupleGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d x1234 y1234:bool=  (quadrupleLess 
  dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y1234 x1234)
let quadrupleGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d x1234 y1234:bool=  (quadrupleLessEq 
  dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y1234 x1234)

let instance_Basic_classes_Ord_tup4_dict dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d:('a*'b*'c*'d)ord_class= ({

  compare_method = (quadrupleCompare  
  dict_Basic_classes_Ord_a.compare_method  dict_Basic_classes_Ord_b.compare_method  dict_Basic_classes_Ord_c.compare_method  dict_Basic_classes_Ord_d.compare_method);

  isLess_method = 
  (quadrupleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d);

  isLessEqual_method = 
  (quadrupleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d);

  isGreater_method = 
  (quadrupleGreater dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c
     dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isGreaterEqual_method = 
  (quadrupleGreaterEq dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c
     dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a)})

let instance_Basic_classes_SetType_tup4_dict dict_Basic_classes_SetType_a dict_Basic_classes_SetType_b dict_Basic_classes_SetType_c dict_Basic_classes_SetType_d:('a*'b*'c*'d)setType_class= ({

  setElemCompare_method = (quadrupleCompare  
  dict_Basic_classes_SetType_a.setElemCompare_method  dict_Basic_classes_SetType_b.setElemCompare_method  dict_Basic_classes_SetType_c.setElemCompare_method  dict_Basic_classes_SetType_d.setElemCompare_method)})

(* quintuples *)

(*val quintupleEqual : forall 'a 'b 'c 'd 'e. Eq 'a, Eq 'b, Eq 'c, Eq 'd, Eq 'e => ('a * 'b * 'c * 'd * 'e) -> ('a * 'b * 'c * 'd * 'e) -> bool*)
let quintupleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e (x1, x2, x3, x4, x5) (y1, y2, y3, y4, y5):bool=  ( (Lem.pair_equal  
  dict_Basic_classes_Eq_a.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_b.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_c.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_d.isEqual_method  dict_Basic_classes_Eq_e.isEqual_method)))(x1, (x2, (x3, (x4, x5)))) (y1, (y2, (y3, (y4, y5))))))

let instance_Basic_classes_Eq_tup5_dict dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e:('a*'b*'c*'d*'e)eq_class= ({

  isEqual_method = 
  (quintupleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b
     dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e);

  isInequal_method = (fun x y->not (quintupleEqual 
  dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e x y))})

(*val quintupleCompare : forall 'a 'b 'c 'd 'e. ('a -> 'a -> ordering) -> ('b -> 'b -> ordering) -> ('c -> 'c -> ordering) ->
                                              ('d -> 'd -> ordering) -> ('e -> 'e -> ordering) -> ('a * 'b * 'c * 'd * 'e) -> ('a * 'b * 'c * 'd * 'e) -> ordering*)
let quintupleCompare cmpa cmpb cmpc cmpd cmpe (a1, b1, c1, d1, e1) (a2, b2, c2, d2, e2):int=  
 (pairCompare cmpa (pairCompare cmpb (pairCompare cmpc (pairCompare cmpd cmpe))) (a1, (b1, (c1, (d1, e1)))) (a2, (b2, (c2, (d2, e2)))))

let quintupleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e (x1, x2, x3, x4, x5) (y1, y2, y3, y4, y5):bool=  (pairLess 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_c
        (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_d
           dict_Basic_classes_Ord_e))) dict_Basic_classes_Ord_a (x1, (x2, (x3, (x4, x5)))) (y1, (y2, (y3, (y4, y5)))))
let quintupleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e (x1, x2, x3, x4, x5) (y1, y2, y3, y4, y5):bool=  (pairLessEq 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_c
        (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_d
           dict_Basic_classes_Ord_e))) dict_Basic_classes_Ord_a (x1, (x2, (x3, (x4, x5)))) (y1, (y2, (y3, (y4, y5)))))

let quintupleGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e x12345 y12345:bool=  (quintupleLess 
  dict_Basic_classes_Ord_e dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y12345 x12345)
let quintupleGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e x12345 y12345:bool=  (quintupleLessEq 
  dict_Basic_classes_Ord_e dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y12345 x12345)

let instance_Basic_classes_Ord_tup5_dict dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e:('a*'b*'c*'d*'e)ord_class= ({

  compare_method = (quintupleCompare  
  dict_Basic_classes_Ord_a.compare_method  dict_Basic_classes_Ord_b.compare_method  dict_Basic_classes_Ord_c.compare_method  dict_Basic_classes_Ord_d.compare_method  dict_Basic_classes_Ord_e.compare_method);

  isLess_method = 
  (quintupleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d
     dict_Basic_classes_Ord_e);

  isLessEqual_method = 
  (quintupleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d
     dict_Basic_classes_Ord_e);

  isGreater_method = 
  (quintupleGreater dict_Basic_classes_Ord_e dict_Basic_classes_Ord_d
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_a);

  isGreaterEqual_method = 
  (quintupleGreaterEq dict_Basic_classes_Ord_e dict_Basic_classes_Ord_d
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_a)})

let instance_Basic_classes_SetType_tup5_dict dict_Basic_classes_SetType_a dict_Basic_classes_SetType_b dict_Basic_classes_SetType_c dict_Basic_classes_SetType_d dict_Basic_classes_SetType_e:('a*'b*'c*'d*'e)setType_class= ({

  setElemCompare_method = (quintupleCompare  
  dict_Basic_classes_SetType_a.setElemCompare_method  dict_Basic_classes_SetType_b.setElemCompare_method  dict_Basic_classes_SetType_c.setElemCompare_method  dict_Basic_classes_SetType_d.setElemCompare_method  dict_Basic_classes_SetType_e.setElemCompare_method)})

(* sextuples *)

(*val sextupleEqual : forall 'a 'b 'c 'd 'e 'f. Eq 'a, Eq 'b, Eq 'c, Eq 'd, Eq 'e, Eq 'f => ('a * 'b * 'c * 'd * 'e * 'f) -> ('a * 'b * 'c * 'd * 'e * 'f) -> bool*)
let sextupleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e dict_Basic_classes_Eq_f (x1, x2, x3, x4, x5, x6) (y1, y2, y3, y4, y5, y6):bool=  ( (Lem.pair_equal  
  dict_Basic_classes_Eq_a.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_b.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_c.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_d.isEqual_method (Lem.pair_equal  dict_Basic_classes_Eq_e.isEqual_method  dict_Basic_classes_Eq_f.isEqual_method))))(x1, (x2, (x3, (x4, (x5, x6))))) (y1, (y2, (y3, (y4, (y5, y6)))))))

let instance_Basic_classes_Eq_tup6_dict dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e dict_Basic_classes_Eq_f:('a*'b*'c*'d*'e*'f)eq_class= ({

  isEqual_method = 
  (sextupleEqual dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b
     dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e
     dict_Basic_classes_Eq_f);

  isInequal_method = (fun x y->not (sextupleEqual 
  dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b dict_Basic_classes_Eq_c dict_Basic_classes_Eq_d dict_Basic_classes_Eq_e dict_Basic_classes_Eq_f x y))})

(*val sextupleCompare : forall 'a 'b 'c 'd 'e 'f. ('a -> 'a -> ordering) -> ('b -> 'b -> ordering) -> ('c -> 'c -> ordering) ->
                                              ('d -> 'd -> ordering) -> ('e -> 'e -> ordering) -> ('f -> 'f -> ordering) ->
                                              ('a * 'b * 'c * 'd * 'e * 'f) -> ('a * 'b * 'c * 'd * 'e * 'f) -> ordering*)
let sextupleCompare cmpa cmpb cmpc cmpd cmpe cmpf (a1, b1, c1, d1, e1, f1) (a2, b2, c2, d2, e2, f2):int=  
 (pairCompare cmpa (pairCompare cmpb (pairCompare cmpc (pairCompare cmpd (pairCompare cmpe cmpf)))) (a1, (b1, (c1, (d1, (e1, f1))))) (a2, (b2, (c2, (d2, (e2, f2))))))

let sextupleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f (x1, x2, x3, x4, x5, x6) (y1, y2, y3, y4, y5, y6):bool=  (pairLess 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_c
        (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_d
           (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_e
              dict_Basic_classes_Ord_f)))) dict_Basic_classes_Ord_a (x1, (x2, (x3, (x4, (x5, x6))))) (y1, (y2, (y3, (y4, (y5, y6))))))
let sextupleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f (x1, x2, x3, x4, x5, x6) (y1, y2, y3, y4, y5, y6):bool=  (pairLessEq 
  (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_b
     (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_c
        (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_d
           (instance_Basic_classes_Ord_tup2_dict dict_Basic_classes_Ord_e
              dict_Basic_classes_Ord_f)))) dict_Basic_classes_Ord_a (x1, (x2, (x3, (x4, (x5, x6))))) (y1, (y2, (y3, (y4, (y5, y6))))))

let sextupleGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f x123456 y123456:bool=  (sextupleLess 
  dict_Basic_classes_Ord_f dict_Basic_classes_Ord_e dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y123456 x123456)
let sextupleGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f x123456 y123456:bool=  (sextupleLessEq 
  dict_Basic_classes_Ord_f dict_Basic_classes_Ord_e dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y123456 x123456)

let instance_Basic_classes_Ord_tup6_dict dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f:('a*'b*'c*'d*'e*'f)ord_class= ({

  compare_method = (sextupleCompare  
  dict_Basic_classes_Ord_a.compare_method  dict_Basic_classes_Ord_b.compare_method  dict_Basic_classes_Ord_c.compare_method  dict_Basic_classes_Ord_d.compare_method  dict_Basic_classes_Ord_e.compare_method  dict_Basic_classes_Ord_f.compare_method);

  isLess_method = 
  (sextupleLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d
     dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f);

  isLessEqual_method = 
  (sextupleLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b
     dict_Basic_classes_Ord_c dict_Basic_classes_Ord_d
     dict_Basic_classes_Ord_e dict_Basic_classes_Ord_f);

  isGreater_method = 
  (sextupleGreater dict_Basic_classes_Ord_f dict_Basic_classes_Ord_e
     dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c
     dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isGreaterEqual_method = 
  (sextupleGreaterEq dict_Basic_classes_Ord_f dict_Basic_classes_Ord_e
     dict_Basic_classes_Ord_d dict_Basic_classes_Ord_c
     dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a)})

let instance_Basic_classes_SetType_tup6_dict dict_Basic_classes_SetType_a dict_Basic_classes_SetType_b dict_Basic_classes_SetType_c dict_Basic_classes_SetType_d dict_Basic_classes_SetType_e dict_Basic_classes_SetType_f:('a*'b*'c*'d*'e*'f)setType_class= ({

  setElemCompare_method = (sextupleCompare  
  dict_Basic_classes_SetType_a.setElemCompare_method  dict_Basic_classes_SetType_b.setElemCompare_method  dict_Basic_classes_SetType_c.setElemCompare_method  dict_Basic_classes_SetType_d.setElemCompare_method  dict_Basic_classes_SetType_e.setElemCompare_method  dict_Basic_classes_SetType_f.setElemCompare_method)})
