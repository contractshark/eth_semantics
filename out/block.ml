(*Generated by Lem from block.lem.*)
(**)
(*Copyright 2016 Sami MÃ¤kelÃ¤*)
(*Copyright 2017 Yoichi Hirai*)
(**)
(* Licensed under the Apache License, Version 2.0 (the "License"); *)
(* you may not use this file except in compliance with the License. *)
(* You may obtain a copy of the License at *)
(**)
(*       http://www.apache.org/licenses/LICENSE-2.0 *)
(**)
(* Unless required by applicable law or agreed to in writing, software *)
(* distributed under the License is distributed on an "AS IS" BASIS, *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

open Lem_pervasives
(*
open import Word
*)
open Word8
open Word160
open Word256
open Keccak
open Evm
open Rlp

type transaction = {
  tr_from : address;
  tr_to :  address option;
  tr_gas_limit : w256;
  tr_gas_price : w256;
  tr_value : w256;
  tr_nonce : w256;
  tr_data : word8 list;
}

type block_account = {
  block_account_address : address;
  block_account_storage : storage;
  block_account_code : program;
  block_account_balance : w256;
  block_account_nonce : w256;
  block_account_exists : bool;
  block_account_hascode : bool;
}

(*val build_cctx : block_account -> constant_ctx*)
let build_cctx0 a:constant_ctx=  
 ({ cctx_program = (a.block_account_code); cctx_this = (a.block_account_address); cctx_hash_filter = (fun _ -> true) })

(* Next we turn to the case where the environment returns back to the account after the account has *)
(* called an account.  In this case, the account should contain one ongoing execution that is waiting *)
(* for a call to return. *)

(* Second I define the empty account, which replaces an account that has *)
(* destroyed itself. *)

(*val empty_account : address -> block_account*)
let empty_account0 addr:block_account=  ({
   block_account_address = addr;
   block_account_storage = empty_storage;
   block_account_code = empty_program;
   block_account_balance =(word256FromNumeral 0);
   block_account_exists = false;
   block_account_nonce =(word256FromNumeral 0);
   block_account_hascode = true;
})

(* And after our contract makes a move, the account state is updated as follows. *)

type world_state = address -> block_account

let empty_state _:address ->block_account=  empty_account0

type receipt = {
  receipt_state : world_state;
  receipt_cumulative_gas : w256;
  receipt_bloom : w256;
  receipt_logs : log_entry list;
}

(*
type block = <|
  block_parent_hash : w256;
  block_uncles_hash : list w256;
  block_coinbase : address;
  block_state : world_state;
  block_transactions : list (transaction * receipt);
  block_logs_bloom : w256;
  block_difficulty : w256;
  block_number : w256;
  block_gas_limit : w256;
  block_timestamp : w256;
  block_nonce : w256;
|>
*)

let start_env a state args caller origin gasprice block:variable_ctx=
 ({ vctx_stack = ([]); (* The stack is initialized for every invocation *)
    vctx_memory = empty_memory; (* The memory is also initialized for every invocation *)
     vctx_memory_usage =(Nat_big_num.of_int 0); (* The memory usage is initialized. *)
     vctx_storage = (a.block_account_storage); (* The storage is taken from the account state *)
     vctx_pc =(Nat_big_num.of_int 0); (* The program counter is initialized to zero *)
     vctx_balance = (fun (addr:address) -> (state addr).block_account_balance);
     vctx_caller = caller; (* the caller is specified by the environment *)
     vctx_value_sent = (args.callarg_value); (* the sent value is specified by the environment *)
     vctx_data_sent = (args.callarg_data); (* the sent data is specified by the environment *)
     vctx_storage_at_call = (a.block_account_storage); (* the snapshot of the storage is remembered in case of failure *)
     vctx_balance_at_call = (fun (addr:address) -> (state addr).block_account_balance); (* the snapshot of the balance is remembered in case of failure *)
     vctx_origin = origin; (* the origin of the transaction is arbitrarily chosen *)
     vctx_gasprice = gasprice; (* the gasprice of the transaction is arbitrarily chosen *)
     vctx_ext_program = (fun (addr:address) -> (state addr).block_account_code); (* the codes of the external programs are arbitrary. *)
     vctx_block = block; (* the block information is chosen arbitrarily. *)
     vctx_gas = (uint args.callarg_gas); (* the amount of gas is chosen arbitrarily. *)
     vctx_account_existence = (fun (addr:address) -> (state addr).block_account_exists); (* existence is chosen arbitrarily *)
     vctx_touched_storage_index = ([]);
     vctx_logs = ([]);
     vctx_refund =(Nat_big_num.of_int 0)
   })

let create_env (a : block_account) state value data gas1 caller origin gasprice block:variable_ctx=
 ({ vctx_stack = ([]); (* The stack is initialized for every invocation *)
    vctx_memory = empty_memory; (* The memory is also initialized for every invocation *)
     vctx_memory_usage =(Nat_big_num.of_int 0); (* The memory usage is initialized. *)
     vctx_storage = (a.block_account_storage); (* The storage is taken from the account state *)
     vctx_pc =(Nat_big_num.of_int 0); (* The program counter is initialized to zero *)
     vctx_balance = (fun (addr:address) -> (state addr).block_account_balance);
     vctx_caller = caller; (* the caller is specified by the environment *)
     vctx_value_sent = value; (* the sent value is specified by the environment *)
     vctx_data_sent = data; (* the sent data is specified by the environment *)
     vctx_storage_at_call = (a.block_account_storage); (* the snapshot of the storage is remembered in case of failure *)
     vctx_balance_at_call = (fun (addr:address) -> (state addr).block_account_balance); (* the snapshot of the balance is remembered in case of failure *)
     vctx_origin = origin; (* the origin of the transaction is arbitrarily chosen *)
     vctx_gasprice = gasprice; (* the gasprice of the transaction is arbitrarily chosen *) 
     vctx_ext_program = (fun (addr:address) -> (state addr).block_account_code); (* the codes of the external programs are arbitrary. *)
     vctx_block = block; (* the block information is chosen arbitrarily. *)
     vctx_gas = gas1; (* the amount of gas is chosen arbitrarily. *)
     vctx_account_existence = (fun (addr:address) -> (state addr).block_account_exists); (* existence is chosen arbitrarily *)
     vctx_touched_storage_index = ([]);
     vctx_logs = ([]);
     vctx_refund =(Nat_big_num.of_int 0)
   })

let vctx_update_from_world v (a : block_account) state called_v:variable_ctx=  ({
     vctx_storage = (a.block_account_storage); (* The storage is taken from the account state *)
     vctx_balance = (fun (addr:address) -> (state addr).block_account_balance);
     vctx_ext_program = (fun (addr:address) -> (state addr).block_account_code); (* the codes of the external programs are arbitrary. *)
     vctx_gas = (Nat_big_num.add v.vctx_gas called_v.vctx_gas);
     vctx_refund = (Nat_big_num.add v.vctx_refund called_v.vctx_refund);
     vctx_logs =  (List.rev_append (List.rev v.vctx_logs) called_v.vctx_logs);
     vctx_account_existence = (fun (addr:address) -> (state addr).block_account_exists); (* existence is chosen arbitrarily *)
     
     vctx_stack = (v.vctx_stack);
     vctx_memory = (v.vctx_memory); (* The memory is also initialized for every invocation *)
     vctx_memory_usage = (v.vctx_memory_usage); (* The memory usage is initialized. *)
     vctx_pc = (v.vctx_pc); (* The program counter is initialized to zero *)
     vctx_caller = (v.vctx_caller); (* the caller is specified by the environment *)
     vctx_value_sent = (v.vctx_value_sent); (* the sent value is specified by the environment *)
     vctx_data_sent = (v.vctx_data_sent); (* the sent data is specified by the environment *)
     vctx_storage_at_call = (v.vctx_storage_at_call); (* the snapshot of the storage is remembered in case of failure *)
     vctx_balance_at_call = (v.vctx_balance_at_call); (* the snapshot of the balance is remembered in case of failure *)
     vctx_origin = (v.vctx_origin); (* the origin of the transaction is arbitrarily chosen *)
     vctx_gasprice = (v.vctx_gasprice);
     vctx_block = (v.vctx_block); (* the block information is chosen arbitrarily. *)
     vctx_touched_storage_index = (v.vctx_touched_storage_index);
})

(*val byte_to_inst : byte -> inst*)
let byte_to_inst b:inst=  ((match word8ToNat b with
 | 0 -> Misc STOP
 | 22 -> Bits Inst_AND
 | 23 -> Bits Inst_OR
 | 24 -> Bits Inst_XOR
 | 25 -> Bits Inst_NOT
 | 26 -> Bits BYTE
 | 240 -> Misc CREATE
 | 241 -> Misc CALL
 | 242 -> Misc CALLCODE
 | 243 -> Misc RETURN
 | 244 -> Misc DELEGATECALL
 | 255 -> Misc SUICIDE
 | 160 -> Log LOG0
 | 161 -> Log LOG1
 | 162 -> Log LOG2
 | 163 -> Log LOG3
 | 164 -> Log LOG4
 | 53 -> Stack CALLDATALOAD
 | 80 -> Stack POP
 | 86 -> Pc JUMP
 | 87 -> Pc JUMPI
 | 88 -> Pc PC
 | 91 -> Pc JUMPDEST
 | 84 -> Storage SLOAD
 | 85 -> Storage SSTORE
 | 81 -> Memory MLOAD
 | 82 -> Memory MSTORE
 | 83 -> Memory MSTORE8
 | 55 -> Memory CALLDATACOPY
 | 57 -> Memory CODECOPY
 | 60 -> Memory EXTCODECOPY
 | 89 -> Memory MSIZE
 | 128 -> Dup(Word4.word4FromNumeral 0)
 | 129 -> Dup(Word4.word4FromNumeral 1)
 | 130 -> Dup(Word4.word4FromNumeral 2)
 | 131 -> Dup(Word4.word4FromNumeral 3)
 | 132 -> Dup(Word4.word4FromNumeral 4)
 | 133 -> Dup(Word4.word4FromNumeral 5)
 | 134 -> Dup(Word4.word4FromNumeral 6)
 | 135 -> Dup(Word4.word4FromNumeral 7)
 | 136 -> Dup(Word4.word4FromNumeral 8)
 | 137 -> Dup(Word4.word4FromNumeral 9)
 | 138 -> Dup(Word4.word4FromNumeral 10)
 | 139 -> Dup(Word4.word4FromNumeral 11)
 | 140 -> Dup(Word4.word4FromNumeral 12)
 | 141 -> Dup(Word4.word4FromNumeral 13)
 | 142 -> Dup(Word4.word4FromNumeral 14)
 | 143 -> Dup(Word4.word4FromNumeral 15)
 | 144 -> Swap(Word4.word4FromNumeral 0)
 | 145 -> Swap(Word4.word4FromNumeral 1)
 | 146 -> Swap(Word4.word4FromNumeral 2)
 | 147 -> Swap(Word4.word4FromNumeral 3)
 | 148 -> Swap(Word4.word4FromNumeral 4)
 | 149 -> Swap(Word4.word4FromNumeral 5)
 | 150 -> Swap(Word4.word4FromNumeral 6)
 | 151 -> Swap(Word4.word4FromNumeral 7)
 | 152 -> Swap(Word4.word4FromNumeral 8)
 | 153 -> Swap(Word4.word4FromNumeral 9)
 | 154 -> Swap(Word4.word4FromNumeral 10)
 | 155 -> Swap(Word4.word4FromNumeral 11)
 | 156 -> Swap(Word4.word4FromNumeral 12)
 | 157 -> Swap(Word4.word4FromNumeral 13)
 | 158 -> Swap(Word4.word4FromNumeral 14)
 | 159 -> Swap(Word4.word4FromNumeral 15)
 | 48 -> Info ADDRESS
 | 49 -> Info BALANCE
 | 50 -> Info ORIGIN
 | 52 -> Info CALLVALUE
 | 54 -> Info CALLDATASIZE
 | 51 -> Info CALLER
 | 56 -> Info CODESIZE
 | 58 -> Info GASPRICE
 | 59 -> Info EXTCODESIZE
 | 64 -> Info BLOCKHASH
 | 65 -> Info COINBASE
 | 66 -> Info TIMESTAMP
 | 67 -> Info NUMBER
 | 68 -> Info DIFFICULTY
 | 69 -> Info GASLIMIT
 | 90 -> Info GAS
 | 1 -> Arith ADD
 | 2 -> Arith MUL
 | 3 -> Arith SUB
 | 4 -> Arith DIV
 | 6 -> Arith MOD
 | 8 -> Arith ADDMOD
 | 9 -> Arith MULMOD
 | 10 -> Arith EXP
 | 17 -> Arith Inst_GT
 | 16 -> Arith Inst_LT
 | 20 -> Arith Inst_EQ
 | 21 -> Arith ISZERO
 | 32 -> Arith SHA3
 | 5 -> Sarith SDIV
 | 7 -> Sarith SMOD
 | 19 -> Sarith SGT
 | 18 -> Sarith SLT
 | 11 -> Sarith SIGNEXTEND
 | _ ->
   if w8Greater b(word8FromNumeral 0X5f) && w8LessEqual b(word8Add(word8FromNumeral 0X5f)(word8FromNumeral 32)) then Stack (PUSH_N (replicate (abs (word8ToInt (word8Minus b(word8FromNumeral 0X5f))))(word8FromNumeral 0))) else
   Unknown b
))

(*val inst_to_byte : inst -> byte*)
let inst_to_byte inst1:word8=  ((match inst1 with
| Unknown byte2 -> byte2
| Bits b -> bits_inst_code b
| Sarith s -> sarith_inst_code s
| Arith a -> arith_inst_code a
| Info i -> info_inst_code i
| Dup d -> dup_inst_code d
| Memory m1 -> memory_inst_code m1
| Storage s -> storage_inst_code s
| Pc p -> pc_inst_code p
| Stack s -> (match list_index (stack_inst_code s)( 0) with None ->(word8FromNumeral 0) | Some x -> x ) 
| Swap s -> swap_inst_code s
| Log l1 -> log_inst_code l1
| Misc m1 -> misc_inst_code m1
))

(*val fix_push : list inst -> list inst*)
let rec fix_push lst:(inst)list=  ((match lst with
 | [] -> []
 | Stack (PUSH_N lst) :: tl -> Stack (PUSH_N (Lem_list.map inst_to_byte (take (List.length lst) tl))) :: fix_push tl
 | a :: tl -> a :: fix_push tl
))

(*val bytelist_to_instlist : list byte -> list inst*)
let bytelist_to_instlist lst:(inst)list=  (fix_push (map byte_to_inst lst))

type stack_hint =
 | NoHint
 | CreateAddress of address
 | ReturnTo of Nat_big_num.num * Nat_big_num.num

type global = {
  g_orig : world_state;
  g_stack : (world_state * variable_ctx * constant_ctx * stack_hint) list;
  g_current : world_state;
  g_cctx : constant_ctx;
  g_killed : address list;
  g_vmstate : instruction_result;
  g_create : bool;
}

type tr_result = {
  f_state : world_state;
  f_killed : address list;
  f_gas : Nat_big_num.num;
  f_refund : Nat_big_num.num;
  f_logs : log_entry list;
}

type global_state =
 | Unimplemented
 | Continue of global
 | Finished of tr_result

let get_hint:(Nat_big_num.num*Nat_big_num.num)option ->stack_hint=  ((function
 | Some (a,b) -> ReturnTo( a, b)
 | None -> NoHint
))

type opt = (int ->  inst option)

let make_opt lst:int ->(inst)option=  
 (let bytes = (bytelist_to_instlist lst) in
  (fun x -> Lem_list.list_index bytes x))

(*val get_opt : opt -> nat -> maybe inst*)
let get_opt m1 x:(inst)option=  (m1 x)

(*val codemap : list byte -> (integer -> maybe inst)*)
let codemap lst:Nat_big_num.num ->(inst)option=  
 (let m1 = (make_opt lst) in
  (fun x -> if Nat_big_num.less x(Nat_big_num.of_int 0) then None else get_opt m1 (abs (Nat_big_num.to_int x))))

let make_program bytes:program=  ({
       program_length = (Nat_big_num.of_int (List.length bytes));
       program_content = (codemap bytes) })

(*val set_account_code : block_account -> list word8 -> block_account*)
let set_account_code acc bytes:block_account=  ({ acc with block_account_code = (make_program bytes) })

(*val update_world : world_state -> address -> block_account -> world_state*)
let update_world state a_addr n_acc a:block_account=  (if a = a_addr then n_acc else state a)

let sub_balance state addr value:address ->block_account=  
 (let acc = (state addr) in
  let acc = ({ acc with block_account_balance = (word256Minus acc.block_account_balance value) }) in
  update_world state addr acc)

let add_balance state addr value:address ->block_account=  
 (let acc = (state addr) in
  let acc = ({ acc with block_account_balance = (word256Add acc.block_account_balance value) }) in
  update_world state addr acc)

let update_return state addr v:address ->block_account=  
 (update_world state addr ({ (state addr) with block_account_storage = (v.vctx_storage) }))

let transfer_balance state addr recv v:address ->block_account=  
 (let state = (sub_balance state addr v) in
  add_balance state recv v)

let update_call state addr args:address ->block_account=  (transfer_balance state addr args.callarg_recipient args.callarg_value)

let update_nonce state addr:address ->block_account=  
 (let acc = (state addr) in
  update_world state addr ({ acc with block_account_nonce = (word256Add acc.block_account_nonce(word256FromNumeral 1)) }))

let create_account n_state new_addr bytes:address ->block_account=  
 (let new_acc = ({ (n_state new_addr) with block_account_exists = true }) in
  let new_acc = (set_account_code new_acc bytes) in
  update_world n_state new_addr new_acc)

let calc_address addr nonce:word160=  (w256_to_address (keccak (rLP (Node [rLP_address addr; rLP_w256 nonce]))))

let step net:global_state ->global_state=  ((function
 | Finished st -> Finished st
 | Unimplemented -> Unimplemented
 | Continue global1 ->
    let orig = (global1.g_orig) in
    let c1 = (global1.g_cctx) in
    let state = (global1.g_current) in
    (match global1.g_vmstate with
    | InstructionToEnvironment( act, v, stuff) ->
      (match act with
      | ContractCall args ->
         if w160Less args.callarg_recipient(word160FromNumeral 256) then
           Unimplemented (* precompiled contracts *)
         else
         let n_state = (update_return state c1.cctx_this v) in
         if word256ULT (n_state c1.cctx_this).block_account_balance args.callarg_value || (List.length global1.g_stack > 1023) then
            let nv = ({ v with vctx_stack =((word256FromNumeral 0) :: v.vctx_stack); vctx_gas = (Nat_big_num.add v.vctx_gas (uint args.callarg_gas)) }) in
            Continue ({ global1 with g_current = n_state; g_vmstate = (InstructionContinue nv) }) else
         let n_state = (update_call n_state c1.cctx_this args) in
         let acc = (n_state args.callarg_recipient) in
         let cctx = ({
            cctx_this = (args.callarg_recipient);
            cctx_program = ((n_state args.callarg_code).block_account_code);
            cctx_hash_filter = (c1.cctx_hash_filter) }) in
         let nv = (start_env acc n_state args c1.cctx_this v.vctx_origin v.vctx_gasprice v.vctx_block) in
         Continue ({ global1 with g_stack=((state,v,c1,get_hint stuff)::global1.g_stack);
                                 g_current=n_state; g_cctx=cctx; g_vmstate=(InstructionContinue nv) })
      | ContractDelegateCall args ->
         let n_state = (update_return state c1.cctx_this v) in
         if List.length global1.g_stack > 1023 then
            let nv = ({ v with vctx_stack =((word256FromNumeral 0) :: v.vctx_stack); vctx_gas = (Nat_big_num.add v.vctx_gas (uint args.callarg_gas)) }) in
            Continue ({ global1 with g_current = n_state; g_vmstate = (InstructionContinue nv) }) else
         let acc = (n_state c1.cctx_this) in
         let cctx = ({
            cctx_this = (c1.cctx_this);
            cctx_program = ((n_state args.callarg_code).block_account_code);
            cctx_hash_filter = (c1.cctx_hash_filter) }) in
         let nv = (start_env acc n_state args v.vctx_caller v.vctx_origin v.vctx_gasprice v.vctx_block) in
         Continue ({ global1 with g_stack=((state,v,c1,get_hint stuff)::global1.g_stack);
                                 g_current=n_state; g_cctx=cctx; g_vmstate=(InstructionContinue nv) })
      | ContractCreate args ->
         let addr = (calc_address c1.cctx_this (state c1.cctx_this).block_account_nonce) in
         if word256ULT (state c1.cctx_this).block_account_balance args.createarg_value || ((List.length global1.g_stack > 1023) || (state addr).block_account_exists) then
            let nv = ({ v with vctx_stack =((word256FromNumeral 0) :: v.vctx_stack) }) in
            Continue ({ global1 with g_current = state; g_vmstate = (InstructionContinue nv) }) else
         let state = (update_nonce state c1.cctx_this) in
         let n_state = (update_return state c1.cctx_this v) in
         let old_acc = (n_state addr) in
         let old_balance = (old_acc.block_account_balance) in
         let acc = (empty_account0 addr) in
         let acc = ({ acc with block_account_balance = old_balance; block_account_exists = true }) in
         let cctx = ({ cctx_this = addr; cctx_program = (make_program args.createarg_code); cctx_hash_filter = (c1.cctx_hash_filter) }) in
         let n_state = (update_world n_state addr acc) in
         let n_state = (transfer_balance n_state c1.cctx_this addr args.createarg_value) in
         let passed_gas : Nat_big_num.num = (if Nat_big_num.greater_equal (word256ToInteger v.vctx_block.block_number) (Nat_big_num.mul(Nat_big_num.of_int 2463)(Nat_big_num.of_int 1000)) then l v.vctx_gas else v.vctx_gas) in
         let remaining_gas = (Nat_big_num.sub v.vctx_gas passed_gas) in
         let nv = (create_env acc n_state args.createarg_value [] 
            passed_gas 
            c1.cctx_this
            v.vctx_origin
            v.vctx_gasprice
            v.vctx_block) in
         let v = ({ v with vctx_gas = remaining_gas }) in
         Continue ({ global1 with g_stack=((state,v,c1,CreateAddress addr)::global1.g_stack);
                                 g_current=n_state; g_cctx=cctx; g_vmstate=(InstructionContinue nv) })
      | ContractFail _ ->
         (match global1.g_stack with
         | [] -> Finished { f_state=orig; f_killed=([]); f_gas=(Nat_big_num.of_int 0); f_refund=(Nat_big_num.of_int 0); f_logs = ([]) }
         | (oldstate,v,c1,_) :: rest ->
           let v = ({ v with vctx_stack =((word256FromNumeral 0)::v.vctx_stack) }) in
           Continue ({ global1 with g_stack=rest; g_current=oldstate; g_cctx=c1; g_vmstate=(InstructionContinue v) })
         )
      | ContractSuicide dst ->
         let n_dst = ({ (state dst) with block_account_balance = (word256Add (state dst).block_account_balance (state c1.cctx_this).block_account_balance) }) in
         let acc = ({ (state c1.cctx_this) with block_account_balance =(word256FromNumeral 0) }) in
         let state = (update_world (update_world state dst n_dst) c1.cctx_this acc) in
         let killed = (c1.cctx_this::global1.g_killed) in
         (match global1.g_stack with
         | [] -> Finished ({ f_state = state; f_killed = killed; f_refund = (v.vctx_refund); f_gas = (v.vctx_gas); f_logs = (v.vctx_logs) })
         | (_,nv,nc,is_new) :: rest ->
           let n_state = ((match is_new with
            | CreateAddress new_addr -> create_account state new_addr []
            | _ -> state
           )) in
           
           if (List.length rest = 0) && global1.g_create then
             Finished { f_state=n_state; f_killed=killed; f_gas=(v.vctx_gas); f_refund=(v.vctx_refund); f_logs = (v.vctx_logs) } else
           let acc = (n_state nc.cctx_this) in
           let nv = ({ nv with vctx_stack =((word256FromNumeral 1)::nv.vctx_stack) }) in
           let nv = (vctx_update_from_world nv acc n_state v) in
           Continue ({ global1 with g_stack=rest; g_current=n_state; g_cctx=nc; g_vmstate=(InstructionContinue nv); g_killed = killed })
         )
      | ContractReturn bytes ->
         let n_state = (update_return state c1.cctx_this v) in
         (match global1.g_stack with
         | [] -> Finished { f_state = n_state; f_killed = (global1.g_killed); f_refund = (v.vctx_refund); f_gas = (v.vctx_gas); f_logs = (v.vctx_logs) }
         | (_,nv,c1,ReturnTo( mem_start, mem_size)) :: rest ->
           let acc = (n_state c1.cctx_this) in
           let nv = ({ nv with vctx_stack =((word256FromNumeral 1)::nv.vctx_stack); vctx_memory = (put_return_values nv.vctx_memory bytes mem_start mem_size) }) in
           let nv = (vctx_update_from_world nv (acc : block_account) n_state v) in
           Continue ({ global1 with g_stack=rest; g_current=n_state; g_cctx=c1; g_vmstate=(InstructionContinue nv) })
         | (old_state,nv,c1,CreateAddress new_addr) :: rest ->
           if (listEqualBy (=) bytes []) && ((List.length rest = 0) && global1.g_create) then
             Finished { f_state=n_state; f_killed=(global1.g_killed); f_gas=(v.vctx_gas); f_refund=(v.vctx_refund); f_logs = (v.vctx_logs) } else
           let (n_state, v, ret1) =              
(if Nat_big_num.less v.vctx_gas (Nat_big_num.of_int ( 200*List.length bytes)) && Nat_big_num.less_equal homestead_block (word256ToInteger v.vctx_block.block_number) then
                 (old_state, { v with vctx_gas =(Nat_big_num.of_int 0) },(word256FromNumeral 0))
              else if Nat_big_num.less v.vctx_gas (Nat_big_num.of_int ( 200*List.length bytes)) then (n_state, v,(word256FromNumeral 0))
              else (create_account n_state new_addr bytes, { v with vctx_gas = (Nat_big_num.sub v.vctx_gas (Nat_big_num.of_int ( 200*List.length bytes))) },
                     address_to_w256 new_addr)) in
           let acc = (n_state c1.cctx_this) in
           let nv = ({ nv with vctx_stack = (ret1::nv.vctx_stack) }) in
           let nv = (vctx_update_from_world nv acc n_state v) in
           Continue ({ global1 with g_stack=rest; g_current=n_state; g_cctx=c1; g_vmstate=(InstructionContinue nv) })
         | _ -> Unimplemented (* should be impossible *)
         )
      )
    | a -> 
      Continue ({ global1 with g_vmstate = (next_state (fun _ -> ()) c1 net a) })
    )
))

(*val txdatacost : list byte -> integer*)
let rec txdatacost lst:Nat_big_num.num=  ((match lst with
 | [] ->Nat_big_num.of_int 0
 | b::lst -> Nat_big_num.add (if b =(word8FromNumeral 0) then Nat_big_num.of_int 4 else Nat_big_num.of_int 68) (txdatacost lst)
))

let calc_igas tr block:Nat_big_num.num=  
 (let igas = (Nat_big_num.add(Nat_big_num.of_int 21000) (txdatacost tr.tr_data)) in
  if Nat_big_num.less (word256ToInteger block.block_number) homestead_block then igas else
  (match tr.tr_to with
  | None -> Nat_big_num.add igas(Nat_big_num.of_int 32000)
  | Some _ -> igas
  ))

let nothing_happens state tr:tr_result=  ({
    f_state=(sub_balance state tr.tr_from ( word256Mult tr.tr_gas_price tr.tr_gas_limit));
    f_killed=([]);
    f_logs = ([]);
    f_gas=(uint tr.tr_gas_limit);
    f_refund=(Nat_big_num.of_int 0) })

let start_transaction tr state block:global_state=  
 (let s_acc = (state tr.tr_from) in
  let gas_value = (Nat_big_num.mul (word256ToNatural tr.tr_gas_price) (word256ToNatural tr.tr_gas_limit)) in
  let igas = (calc_igas tr block) in
  (* does not work because gas can overflow ... *)
  let nothing = (Finished (nothing_happens state tr)) in
  if unsafe_structural_inequality tr.tr_nonce s_acc.block_account_nonce then nothing else
  if Nat_big_num.less (word256ToNatural s_acc.block_account_balance) (Nat_big_num.add (word256ToNatural tr.tr_value) gas_value) then nothing else
  let gas_value = (word256Mult tr.tr_gas_price tr.tr_gas_limit) in
  if Nat_big_num.less (word256ToNatural block.block_gaslimit) (word256ToNatural tr.tr_gas_limit) then nothing else
  if Nat_big_num.less (word256ToNatural tr.tr_gas_limit) (Nat_big_num.abs igas) then nothing else
  (match tr.tr_to with
  | None ->
    if (listEqualBy (=) tr.tr_data []) && ((tr.tr_gas_limit =(word256FromNumeral 0)) && (tr.tr_gas_price =(word256FromNumeral 0))) then nothing else
    if (listEqualBy (=) tr.tr_data []) && (tr.tr_gas_price =(word256FromNumeral 0)) then Finished { f_state=(update_nonce state tr.tr_from); f_killed=([]); f_gas=(Nat_big_num.of_int 0); f_refund=(Nat_big_num.of_int 0); f_logs = ([]) } else
    (* This should be creation... perhaps make a bogus state *)
    let s_acc = ({ s_acc with block_account_balance = (word256Minus s_acc.block_account_balance gas_value) }) in
    let n_state = (update_world state tr.tr_from s_acc) in
    if (listEqualBy (=) tr.tr_data []) then
      Finished { f_state=(update_nonce n_state tr.tr_from); f_killed=([]); f_gas= (Nat_big_num.sub((word256ToNatural tr.tr_gas_limit)) igas); f_refund=(Nat_big_num.of_int 0); f_logs=([]) } else
    let v = (create_env s_acc n_state(word256FromNumeral 0) []
        (word256ToInteger ( word256Minus tr.tr_gas_limit (word256FromInteger igas))) tr.tr_from tr.tr_from tr.tr_gas_price block) in
    let c1 = (build_cctx0 s_acc) in
    let args = ({ createarg_value = (tr.tr_value); createarg_code = (tr.tr_data) }) in
    let act = (ContractCreate args) in
    Continue ({ g_create = true; g_orig = n_state; g_stack = ([]); g_current = n_state; g_cctx = c1; g_vmstate = (InstructionToEnvironment( act, v, None)); g_killed = ([]) })
  | Some addr ->
    let s_acc = ({ s_acc with block_account_nonce = (word256Add s_acc.block_account_nonce(word256FromNumeral 1));  block_account_balance = (word256Minus s_acc.block_account_balance gas_value) }) in
    let state2 = (update_world state tr.tr_from s_acc) in
    if Nat_big_num.less (word256ToNatural s_acc.block_account_balance) (word256ToNatural tr.tr_value) then nothing else
    let s_acc = ({ s_acc with block_account_balance = (word256Minus s_acc.block_account_balance tr.tr_value) }) in
    let n_state = (update_world state tr.tr_from s_acc) in
    let acc = (n_state addr) in
    let acc = ({ acc with block_account_balance = (word256Add acc.block_account_balance tr.tr_value) }) in
    let n_state = (update_world n_state addr acc) in
    let v = (create_env acc n_state tr.tr_value tr.tr_data ( Nat_big_num.sub(uint tr.tr_gas_limit) igas) tr.tr_from tr.tr_from tr.tr_gas_price block) in
    let c1 = (build_cctx0 acc) in
    Continue ({ g_create = false; g_orig = state2; g_stack = ([]); g_current = n_state; g_cctx = c1; g_vmstate = (InstructionContinue v); g_killed = ([]) })
))

let rec kill_accounts state killed:address ->block_account=  ((match killed with
  | [] -> state
  | a::rest -> kill_accounts (update_world state a (empty_account0 a)) rest
))

(*val refund_selfdestruct : natural*)
let refund_selfdestruct:Nat_big_num.num= (Nat_big_num.of_int 24000)

let end_transaction f tr block:address ->block_account=  
 (let state = (kill_accounts f.f_state f.f_killed) in
  let refund = (Nat_big_num.add (Nat_big_num.mul (Nat_big_num.of_int (List.length f.f_killed)) refund_selfdestruct) (Nat_big_num.abs f.f_refund)) in
  (* refund gas to account *)
  let r = (Nat_big_num.add (Nat_big_num.abs f.f_gas) (Nat_big_num.min refund ( Nat_big_num.div( Nat_big_num.sub_nat(word256ToNatural tr.tr_gas_limit) (Nat_big_num.abs f.f_gas))(Nat_big_num.of_int 2)))) in
  let refund_sum = (word256FromNatural ( Nat_big_num.mul r (word256ToNatural tr.tr_gas_price))) in
  let state = (add_balance state tr.tr_from refund_sum) in
  add_balance state block.block_coinbase ( word256Minus (word256Mult tr.tr_gas_limit tr.tr_gas_price) refund_sum))


