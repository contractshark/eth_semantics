(*Generated by Lem from word8.lem.*)
(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)
open Lem_pervasives
open Lem_word

type word8 = W8 of bool * bool list

(* perhaps should truncate here? *)
(*val bs_to_w8 : bitSequence -> word8*)
let bs_to_w8 seq:word8=  ((match resizeBitSeq (Some( 8)) seq with
 | BitSeq( _, s, b) -> W8( s, b)
))

(*val w8_to_bs : word8 -> bitSequence*)
let w8_to_bs (W8( s, b)):bitSequence=  (BitSeq( (Some( 8)), s, b))

(*val word8BinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word8 -> word8 -> 'a*)
let word8BinTest binop w1 w2:'a=  (binop (w8_to_bs w1) (w8_to_bs w2))

(*val word8BinOp : (bitSequence -> bitSequence -> bitSequence) -> word8 -> word8 -> word8*)
let word8BinOp binop w1 w2:word8=  (bs_to_w8 (binop (w8_to_bs w1) (w8_to_bs w2)))

(*val word8NatOp : (bitSequence -> nat -> bitSequence) -> word8 -> nat -> word8*)
let word8NatOp binop w1 n:word8=  (bs_to_w8 (binop (w8_to_bs w1) n))

(*val word8UnaryOp : (bitSequence -> bitSequence) -> word8 -> word8*)
let word8UnaryOp op w:word8=  (bs_to_w8 (op (w8_to_bs w)))

(*val word8ToNat : word8 -> nat*)
let word8ToNat w:int=  (abs ( Nat_num.int_mod(Nat_big_num.to_int (integerFromBitSeq (w8_to_bs w)))( 256)))

(*val word8ToNatural : word8 -> natural*)
let word8ToNatural w:Nat_big_num.num=  (Nat_big_num.of_int (abs ( Nat_num.int_mod(Nat_big_num.to_int (integerFromBitSeq (w8_to_bs w)))( 256))))

(*val word8ToInt : word8 -> int*)
let word8ToInt w:int=  (Nat_big_num.to_int (integerFromBitSeq (w8_to_bs w)))

(*val word8ToUInt : word8 -> int*)
let word8ToUInt w:int=  ((word8ToNat w))

(*val word8FromInteger : integer -> word8*)
let word8FromInteger i:word8=  (bs_to_w8 (bitSeqFromInteger (Some( 8)) i))

(*val word8FromInt : int -> word8*)
let word8FromInt i:word8=  (bs_to_w8 (bitSeqFromInteger (Some( 8)) (Nat_big_num.of_int i)))

(*val word8FromNat : nat -> word8*)
let word8FromNat i:word8=  (word8FromInteger (Nat_big_num.of_int i))

(*val word8FromNatural : natural -> word8*)
let word8FromNatural i:word8=  (word8FromInteger ( i))

(*val word8FromBoollist : list bool -> word8*)
let word8FromBoollist lst:word8=  ((match bitSeqFromBoolList (List.rev lst) with
 | None -> bs_to_w8(bitSeqFromInteger None (Nat_big_num.of_int 0))
 | Some a -> bs_to_w8 a
))

(*val boolListFromWord8 : word8 -> list bool*)
let boolListFromWord8 w:(bool)list=  (List.rev (boolListFrombitSeq( 8) (w8_to_bs w)))

(*val word8FromNumeral : numeral -> word8*)
let word8FromNumeral w:word8=  (bs_to_w8 (bitSeqFromInteger None (Nat_big_num.of_int w)))

(*val w8Eq : word8 -> word8 -> bool*)
let w8Eq:word8 ->word8 ->bool=  (=)

(*val w8Less : word8 -> word8 -> bool*)
let w8Less bs1 bs2:bool=  (word8BinTest bitSeqLess bs1 bs2)

(*val w8LessEqual : word8 -> word8 -> bool*)
let w8LessEqual bs1 bs2:bool=  (word8BinTest bitSeqLessEqual bs1 bs2)

(*val w8Greater : word8 -> word8 -> bool*)
let w8Greater bs1 bs2:bool=  (word8BinTest bitSeqGreater bs1 bs2)

(*val w8GreaterEqual : word8 -> word8 -> bool*)
let w8GreaterEqual bs1 bs2:bool=  (word8BinTest bitSeqGreaterEqual bs1 bs2)

(*val w8Compare : word8 -> word8 -> ordering*)
let w8Compare bs1 bs2:int=  (word8BinTest bitSeqCompare bs1 bs2)

let instance_Basic_classes_Ord_Word8_word8_dict:(word8)ord_class= ({

  compare_method = w8Compare;

  isLess_method = w8Less;

  isLessEqual_method = w8LessEqual;

  isGreater_method = w8Greater;

  isGreaterEqual_method = w8GreaterEqual})

let instance_Basic_classes_SetType_Word8_word8_dict:(word8)setType_class= ({

  setElemCompare_method = w8Compare})

(*val word8Negate : word8 -> word8*)
let word8Negate:word8 ->word8=  (word8UnaryOp bitSeqNegate)

(*val word8Succ : word8 -> word8*)
let word8Succ:word8 ->word8=  (word8UnaryOp bitSeqSucc)

(*val word8Pred : word8 -> word8*)
let word8Pred:word8 ->word8=  (word8UnaryOp bitSeqPred)

(*val word8Lnot : word8 -> word8*)
let word8Lnot:word8 ->word8=  (word8UnaryOp bitSeqNot)

(*val word8Add : word8 -> word8 -> word8*)
let word8Add:word8 ->word8 ->word8=  (word8BinOp bitSeqAdd)

(*val word8Minus : word8 -> word8 -> word8*)
let word8Minus:word8 ->word8 ->word8=  (word8BinOp bitSeqMinus)

(*val word8Mult : word8 -> word8 -> word8*)
let word8Mult:word8 ->word8 ->word8=  (word8BinOp bitSeqMult)

(*val word8IntegerDivision : word8 -> word8 -> word8*)
let word8IntegerDivision:word8 ->word8 ->word8=  (word8BinOp bitSeqDiv)

(*val word8Division : word8 -> word8 -> word8*)
let word8Division:word8 ->word8 ->word8=  (word8BinOp bitSeqDiv)

(*val word8Remainder : word8 -> word8 -> word8*)
let word8Remainder:word8 ->word8 ->word8=  (word8BinOp bitSeqMod)

(*val word8Land : word8 -> word8 -> word8*)
let word8Land:word8 ->word8 ->word8=  (word8BinOp bitSeqAnd)

(*val word8Lor : word8 -> word8 -> word8*)
let word8Lor:word8 ->word8 ->word8=  (word8BinOp bitSeqOr)

(*val word8Lxor : word8 -> word8 -> word8*)
let word8Lxor:word8 ->word8 ->word8=  (word8BinOp bitSeqXor)

(*val word8Min : word8 -> word8 -> word8*)
let word8Min:word8 ->word8 ->word8=  (word8BinOp (bitSeqMin))

(*val word8Max : word8 -> word8 -> word8*)
let word8Max:word8 ->word8 ->word8=  (word8BinOp (bitSeqMax))

(*val word8Power : word8 -> nat -> word8*)
let word8Power:word8 ->int ->word8=  (word8NatOp bitSeqPow)

(*val word8Asr : word8 -> nat -> word8*)
let word8Asr:word8 ->int ->word8=  (word8NatOp bitSeqArithmeticShiftRight)

(*val word8Lsr : word8 -> nat -> word8*)
let word8Lsr:word8 ->int ->word8=  (word8NatOp bitSeqLogicalShiftRight)

(*val word8Lsl : word8 -> nat -> word8*)
let word8Lsl:word8 ->int ->word8=  (word8NatOp bitSeqShiftLeft)


let instance_Num_NumNegate_Word8_word8_dict:(word8)numNegate_class= ({

  numNegate_method = word8Negate})

let instance_Num_NumAdd_Word8_word8_dict:(word8)numAdd_class= ({

  numAdd_method = word8Add})

let instance_Num_NumMinus_Word8_word8_dict:(word8)numMinus_class= ({

  numMinus_method = word8Minus})

let instance_Num_NumSucc_Word8_word8_dict:(word8)numSucc_class= ({

  succ_method = word8Succ})

let instance_Num_NumPred_Word8_word8_dict:(word8)numPred_class= ({

  pred_method = word8Pred})

let instance_Num_NumMult_Word8_word8_dict:(word8)numMult_class= ({

  numMult_method = word8Mult})

let instance_Num_NumPow_Word8_word8_dict:(word8)numPow_class= ({

  numPow_method = word8Power})

let instance_Num_NumIntegerDivision_Word8_word8_dict:(word8)numIntegerDivision_class= ({

  div_method = word8IntegerDivision})

let instance_Num_NumDivision_Word8_word8_dict:(word8)numDivision_class= ({

  numDivision_method = word8Division})

let instance_Num_NumRemainder_Word8_word8_dict:(word8)numRemainder_class= ({

  mod_method = word8Remainder})

let instance_Basic_classes_OrdMaxMin_Word8_word8_dict:(word8)ordMaxMin_class= ({

  max_method = word8Max;

  min_method = word8Min})

let instance_Word_WordNot_Word8_word8_dict:(word8)wordNot_class= ({

  lnot_method = word8Lnot})

let instance_Word_WordAnd_Word8_word8_dict:(word8)wordAnd_class= ({

  land_method = word8Land})

let instance_Word_WordOr_Word8_word8_dict:(word8)wordOr_class= ({

  lor_method = word8Lor})

let instance_Word_WordXor_Word8_word8_dict:(word8)wordXor_class= ({

  lxor_method = word8Lxor})

let instance_Word_WordLsl_Word8_word8_dict:(word8)wordLsl_class= ({

  lsl_method = word8Lsl})

let instance_Word_WordLsr_Word8_word8_dict:(word8)wordLsr_class= ({

  lsr_method = word8Lsr})

let instance_Word_WordAsr_Word8_word8_dict:(word8)wordAsr_class= ({

  asr_method = word8Asr})

(*val word8UGT : word8 -> word8 -> bool*)
let word8UGT a b:bool=  (word8ToNat a > word8ToNat b)

