(*Generated by Lem from rlp.lem.*)
(**)
(* Copyright 2016 Sami MÃ¤kelÃ¤ *)
(*  Licensed under the Apache License, Version 2.0 (the "License"); *)
(*  you may not use this file except in compliance with the License. *)
(*  You may obtain a copy of the License at *)
(**)
(*     http://www.apache.org/licenses/LICENSE-2.0 *)
(**)
(* Unless required by applicable law or agreed to in writing, software *)
(* distributed under the License is distributed on an "AS IS" BASIS, *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

open Lem_pervasives
open Lem_word
open Word256
open Word160
open Word8
open Keccak

type byte0 = word8

type tree =
 | Leaf of byte0 list
 | Node of tree list

(*val BE_rev_prim : natural -> natural -> list byte*)
let rec bE_rev_prim limit n:(word8)list= 
  (
  if(Nat_big_num.equal limit (Nat_big_num.of_int 0)) then ([]) else
    (let limit0 =(Nat_big_num.sub_nat limit (Nat_big_num.of_int 1)) in
     if Nat_big_num.equal n (Nat_big_num.of_int 0) then [] else
       if Nat_big_num.less n (Nat_big_num.of_int 256) then
         [word8FromNatural n] else
         (word8FromNatural ( Nat_big_num.modulus n (Nat_big_num.of_int 256))
            ::
            bE_rev_prim limit0 ( Nat_big_num.div n (Nat_big_num.of_int 256)))))

(*val BE_rev : natural -> list byte*)
let rec bE_rev n:(word8)list= 
  (
  if(Nat_big_num.equal n (Nat_big_num.of_int 0)) then ([]) else
    (
    if Nat_big_num.less n (Nat_big_num.of_int 256) then [word8FromNatural n]
    else
      (word8FromNatural ( Nat_big_num.modulus n (Nat_big_num.of_int 256)) ::
         bE_rev ( Nat_big_num.div n (Nat_big_num.of_int 256)))))

(*val BE : natural -> list byte*)
let bE n:(word8)list=  (List.rev (bE_rev n))

(*val BE_nat : nat -> list byte*)
let bE_nat n:(word8)list=  (List.rev (bE_rev (Nat_big_num.of_int n)))

(*val BD_rev : list byte -> natural*)
let rec bD_rev lst:Nat_big_num.num=  ((match lst with
 | [] ->Nat_big_num.of_int 0
 | h :: t -> Nat_big_num.add (Nat_big_num.mul(Nat_big_num.of_int 256) (bD_rev t)) (word8ToNatural h)
))

(*val BD : list byte -> natural*)
let bD lst:Nat_big_num.num=  (bD_rev (List.rev lst))

(*val r_b : list byte -> list byte*)
let r_b lst:(word8)list=  ((match lst with
 | [] -> [(word8FromNumeral 128)]
 | [k] -> if word8ToNat k < 128 then [k] else [(word8FromNumeral 129); k]
 | lst ->
   if List.length lst < 56 then word8FromNat ( 128 + List.length lst) :: lst
    else word8FromNat ( 183 + List.length (bE_nat (List.length lst))) ::  List.rev_append (List.rev (bE_nat (List.length lst))) lst
))

(*val read_n_bytes : nat -> list byte -> maybe (list byte  * list byte)*)
let read_n_bytes n lst:((word8)list*(word8)list)option=  
 (if List.length lst >= n then Some (take n lst, drop n lst)
  else None)

(*val de_r_b : list byte -> maybe (list byte * list byte)*)
let de_r_b lst:((word8)list*(word8)list)option=  ((match lst with
 | [] -> None
 | k :: lst ->
   if k =(word8FromNumeral 128) then Some ([], lst)
   else if w8Less k(word8FromNumeral 128) then Some ([k], lst)
   else if w8Less k(word8FromNumeral 184) then
       (let len = (Nat_num.nat_monus (word8ToNat k)( 128)) in
       (if List.length lst >= len then Some (take len lst, drop len lst)
                                         else None))
   else if w8LessEqual k(word8FromNumeral 192) then
      (match read_n_bytes ( Nat_num.nat_monus(word8ToNat k)( 183)) lst with
       | None -> None
       | Some (be_bytes, x_and_rest) ->
         read_n_bytes (Nat_big_num.to_int (bD be_bytes)) x_and_rest
      )
   else None
))

(*val RLP : tree -> list byte*)
let rec rLP tree1:(word8)list=  ((match tree1 with
 | Leaf l1 -> r_b l1
 | Node lst ->
   let s = (List.concat (map rLP lst)) in
   let len_s = (List.length s) in
   if len_s < 56 then word8FromNat ( 192 + len_s) :: s
   else word8FromNat ( 247 + List.length (bE_nat len_s)) :: ( List.rev_append (List.rev (bE_nat len_s)) s)
))   

(*val RLP_nat : natural -> list byte*)
let rLP_nat i:(byte0)list=  (rLP (Leaf (bE i)))

(*val RLP_w256 : word256 -> tree*)
let rLP_w256 i:tree=  (Leaf (bE (Nat_big_num.abs (word256ToInteger i))))

(*val word_rsplit160 : word160 -> list byte*)
let word_rsplit160 w:(Keccak.byte)list=  (word_rsplit_aux (boolListFromWord160 w)( 20))

(*
val RLP_address : word160 -> tree
let RLP_address i = Leaf (BE (naturalFromInteger (word160ToInteger i)))
*)

(*val RLP_address : word160 -> tree*)
let rLP_address addr:tree=  (Leaf (word_rsplit160 addr))

